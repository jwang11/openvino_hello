// Copyright (C) 2018-2019 Intel Corporation
// SPDX-License-Identifier: Apache-2.0
//

#include <vector>
#include <memory>
#include <string>
#include <ie_blob.h>
#include <inference_engine.hpp>
#include <opencv2/opencv.hpp>

using namespace InferenceEngine;

int main(int argc, char *argv[]) {
    // ------------------------------ Parsing and validation of input args ---------------------------------
    if (argc != 4) {
        std::cout << "Usage : " << argv[0] << " <path_to_model> <path_to_image> <device_name>" << std::endl;
        return EXIT_FAILURE;
    }

    const file_name_t input_model{argv[1]};
    const file_name_t input_image_path{argv[2]};
    const std::string device_name{argv[3]};


    // --------------------------- 1. Load inference engine instance -------------------------------------
    Core ie;

    // --------------------------- 2. Read IR Generated by ModelOptimizer (.xml and .bin files) ------------
    CNNNetReader network_reader;
    network_reader.ReadNetwork(fileNameToString(input_model));
    network_reader.ReadWeights(fileNameToString(input_model).substr(0, input_model.size() - 4) + ".bin");
    network_reader.getNetwork().setBatchSize(1);
    CNNNetwork network = network_reader.getNetwork();

    // --------------------------- 3. Configure input & output ---------------------------------------------
    // --------------------------- Prepare input blobs -----------------------------------------------------
    InputInfo::Ptr input_info = network.getInputsInfo().begin()->second;
    std::string input_name = network.getInputsInfo().begin()->first;

    /* Mark input as resizable by setting of a resize algorithm.
     * In this case we will be able to set an input blob of any shape to an infer request.
     * Resize and layout conversions are executed automatically during inference */
    input_info->getPreProcess().setResizeAlgorithm(RESIZE_BILINEAR);
    input_info->setLayout(Layout::NHWC);
    input_info->setPrecision(Precision::U8);

    // --------------------------- Prepare output blobs ----------------------------------------------------
    DataPtr output_info = network.getOutputsInfo().begin()->second;
    std::string output_name = network.getOutputsInfo().begin()->first;

    output_info->setPrecision(Precision::FP32);

    // --------------------------- 4. Loading model to the device ------------------------------------------
    ExecutableNetwork executable_network = ie.LoadNetwork(network, device_name);

    // --------------------------- 5. Create infer request -------------------------------------------------
    InferRequest infer_request = executable_network.CreateInferRequest();

    // --------------------------- 6. Prepare input --------------------------------------------------------
    /* Read input image to a blob and set it to an infer request without resize and layout conversions. */
    cv::Mat mat = cv::imread(input_image_path);
    size_t channels = mat.channels();
    size_t height = mat.size().height;
    size_t width = mat.size().width;

    InferenceEngine::TensorDesc tDesc(InferenceEngine::Precision::U8,
                                      {1, channels, height, width},
                                      InferenceEngine::Layout::NHWC);

    Blob::Ptr imgBlob = InferenceEngine::make_shared_blob<uint8_t>(tDesc, mat.data);
    infer_request.SetBlob(input_name, imgBlob);  // infer_request accepts input blob of any size

    // --------------------------- 7. Do inference --------------------------------------------------------
    /* Running the request synchronously */
    infer_request.Infer();

    // --------------------------- 8. Process output ------------------------------------------------------
    Blob::Ptr output = infer_request.GetBlob(output_name);
    std::vector<unsigned> results;
    TopResults(10, *output, results);

    // Print classification results
    std::cout << std::endl << "Top 10 results:" << std::endl << std::endl;
    for (size_t id = 0; id < 10; ++id) {
        /** Getting probability for resulting class **/
        const auto result = output->buffer().
                    as<InferenceEngine::PrecisionTrait<InferenceEngine::Precision::FP32>::value_type*>()
                    [results[id]];
        std::cout << std::left << results[id] << "\t" << std::fixed << result << std::endl;
    }
    std::cout << std::endl;
    return EXIT_SUCCESS;
}
